import hashes, math, json, tables, strutils, times, os, logging
import sha256

type BlockChain* = ref object
  blocks*: seq[JsonNode]
  transactions*: seq[JsonNode]

# @staticmethod
proc hash*(this: BlockChain, blockdata: JsonNode): string {.noSideEffect.} =
  ##[
    This function hashes the block using the SHA-256 hash algorithm
    The function is given a block and returns a string, consisting of the hash
      :param blockdata: <JsonNode> Block
      :return: <str>
  ]##

  # return intToStr(blockdata.hash().abs())
  return SHA256(intToStr(blockdata.hash.abs))

# @property
proc last_block*(this: BlockChain): JsonNode {.noSideEffect.} =
  return this.blocks[this.blocks.high]

proc create_new_block*(this: BlockChain, proof: int, previous_hash: string = nil): JsonNode =
  ##[
    Creates a new block and adds it to the blockchain
      :param proof: <int> This is generated by the proof of work algorithm
      :param previous_hash: (Optional) <str> Hash of the preleading Block
      :return: <dict> Return the new block 
  ]##

  var hash: string
  if previous_hash.isNil:
    hash = this.hash(this.blocks[this.blocks.high])
  else:
    hash = previous_hash

  var new_block: JsonNode = %*
    {
      "height": len(this.blocks) + 1,
      "time": epochTime(),
      "tx": this.transactions,
      "proof": proof,
      "previousblockhash": hash
    }

  # As all pending transactions have been processed and added to the block, the list can be resetted
  this.transactions = @[]

  # Add the new block to the blockchain
  this.blocks.add(new_block)
  return new_block

proc create_new_tx*(this: BlockChain, sender: string, recipient: string, amount: int): int =
  ##[
    This function creates a new transaction that will then be placed in a new block, alone or bundled together with other transactions.
      :param sender: <str> Sender's address
      :param recipient: <str> Recipient's address
      :param amount: <int> Amount to be transferred
      :return: <int> This is the index of the block that will contain this transaction
  ]##

  var tx: JsonNode = %*
    {
      "sender": sender,
      "recipient": recipient,
      "amount": amount
    }
  this.transactions.add(tx)
  return this.last_block["height"].getInt() + 1

proc init*(this: BlockChain) =
  this.blocks = @[]
  this.transactions = @[]

  # var fL = newFileLogger("log/pow.log", fmtStr = verboseFmtStr)
  # addHandler(fL)
  var L = newConsoleLogger(fmtStr = verboseFmtStr, levelThreshold = lvlWarn)
  addHandler(L)

  # Create genesis block
  discard this.create_new_block(previous_hash="1", proof=100)

proc validate_proof*(last_proof: int, current_proof: int): bool =
  ##[
    Returns, whether the hash of the lastproof and the current_proof contains 4 leading characters (00bc).
      :param last_proof: <int> Previous Proof Number
      :param current_proof: <int> Current Proof Number
      :return: <bool>
  ]##

  let concat = intToStr(last_proof) & intToStr(current_proof)
  let possible_hash = SHA256(concat)
  let leading = possible_hash[0..3]
  debug("Possible hash: ", possible_hash, " with leading ", leading, " at current proof ", current_proof)

  let found = leading == "00bc"
  if (found):
    echo "Proof hash: ", possible_hash
  return found

proc pow*(this: BlockChain, last_proof: int): int =
  ##[
    Simple PoW Algorithm:
       - Find a number y, so that SHA256(xy) contains 4 leading characters (00bc). x is the last y aka last_proof. y is then the new proof.
      :param last_proof: <int>
      :return: <int>
  ]##
  
  let t0 = cpuTime()
  echo "Start mining: last_proof=", last_proof
  var current_proof = 0
  while validate_proof(last_proof, current_proof) == false:
    current_proof += 1
  echo "Found proof: ", current_proof, "\nTIME ELAPSED: ", cpuTime() - t0, " s"

  return current_proof